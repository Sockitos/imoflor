-- =============================================
-- SCHEMA: Contracts
-- DESCRIPTION: ...
-- =============================================
-- Enums
CREATE TYPE public.contract_type AS enum(
  'renting',
  'lending'
);

-- Tables
CREATE TABLE public.contracts(
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  updated_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  type contract_type NOT NULL,
  start_date timestamp with time zone NOT NULL,
  end_date timestamp with time zone,
  fraction_id bigint NOT NULL REFERENCES fractions(id) ON DELETE CASCADE,
  is_active boolean NOT NULL DEFAULT TRUE,
  UNIQUE (id, type),
  UNIQUE (fraction_id, is_active)
);

CREATE TRIGGER handle_updated_at
  BEFORE UPDATE ON public.contracts
  FOR EACH ROW
  EXECUTE PROCEDURE moddatetime(updated_at);

CREATE TABLE public.contracts_tenants(
  contract_id bigint NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
  tenant_id bigint NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  PRIMARY KEY (contract_id, tenant_id)
);

CREATE TABLE public.due_notes(
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  contract_id bigint NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
  due_date timestamp with time zone NOT NULL,
  value double precision NOT NULL
);

CREATE TABLE public.renting_contracts(
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  contract_type contract_type NOT NULL GENERATED ALWAYS AS ('renting'::contract_type) STORED,
  FOREIGN KEY (id, contract_type) REFERENCES contracts(id, type) ON DELETE CASCADE
);

CREATE TRIGGER handle_updated_at
  BEFORE UPDATE ON public.renting_contracts
  FOR EACH ROW
  EXECUTE PROCEDURE moddatetime(updated_at);

CREATE TABLE public.rent_updates(
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  update_date timestamp with time zone NOT NULL,
  rent double precision NOT NULL,
  contract_id bigint NOT NULL REFERENCES public.renting_contracts(id) ON DELETE CASCADE
);

CREATE TABLE public.rent_payments(
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  contract_id bigint NOT NULL REFERENCES renting_contracts(id) ON DELETE CASCADE,
  movement_id bigint NOT NULL REFERENCES movements(id)
);

CREATE TABLE public.lending_contracts(
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  contract_type contract_type NOT NULL GENERATED ALWAYS AS ('lending'::contract_type) STORED,
  sale_value double precision NOT NULL,
  down_payment double precision NOT NULL,
  yearly_raise double precision NOT NULL,
  FOREIGN KEY (id, contract_type) REFERENCES contracts(id, type) ON DELETE CASCADE
);

CREATE TRIGGER handle_updated_at
  BEFORE UPDATE ON public.lending_contracts
  FOR EACH ROW
  EXECUTE PROCEDURE moddatetime(updated_at);

CREATE TABLE public.installment_updates(
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  update_date timestamp with time zone NOT NULL,
  installment double precision NOT NULL,
  interest double precision NOT NULL,
  contract_id bigint NOT NULL REFERENCES public.lending_contracts(id) ON DELETE CASCADE
);

CREATE TABLE public.installment_payments(
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  inserted_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  contract_id bigint NOT NULL REFERENCES lending_contracts(id) ON DELETE CASCADE,
  interest_movement_id bigint NOT NULL REFERENCES movements(id),
  amortization_movement_id bigint REFERENCES movements(id),
  extra_debt double precision
);

-- Views
CREATE VIEW public.rent_payments_view AS
SELECT
  rp.contract_id,
  rp.id,
  m.value,
  m.date,
  m.description
FROM
  public.rent_payments rp
  JOIN public.movements m ON rp.movement_id = m.id;

CREATE VIEW public.installment_payments_view AS
SELECT
  ip.contract_id,
  ip.id,
  i.date,
  i.value AS interest,
  coalesce(a.value, 0) AS amortization,
  ip.extra_debt,
  i.description
FROM
  public.installment_payments ip
  LEFT JOIN public.movements a ON ip.amortization_movement_id = a.id
  LEFT JOIN public.movements i ON ip.interest_movement_id = i.id;

CREATE VIEW public.contracts_accounts_view AS
SELECT
  dn.contract_id,
  dn.id,
  'due_note' AS type,
  dn.due_date AS date,
  -1 * dn.value AS value
FROM
  public.due_notes dn
UNION
SELECT
  rp.contract_id,
  rp.id,
  'payment' AS type,
  rp.date AS date,
  rp.value AS value
FROM
  public.rent_payments_view rp
UNION
SELECT
  ip.contract_id,
  ip.id,
  'payment' AS type,
  ip.date AS date,
  ip.interest + ip.amortization AS value
FROM
  public.installment_payments_view ip;

CREATE VIEW public.contracts_balances_view AS
SELECT
  c.id AS contract_id,
  coalesce(sum(ca.value), 0) AS balance
FROM
  public.contracts c
  LEFT JOIN public.contracts_accounts_view ca ON c.id = ca.contract_id
GROUP BY
  c.id;

CREATE VIEW public.lending_contracts_debts_view AS
SELECT
  lc.id,
  lc.sale_value - lc.down_payment - coalesce(sum(ip.amortization), 0) AS debt,
  coalesce((
    SELECT
      ip.extra_debt
    FROM public.installment_payments_view ip
    WHERE
      ip.contract_id = lc.id ORDER BY ip.date DESC LIMIT 1), 0) AS extra_debt,
  max(ip.date) AS last_payment_date
FROM
  public.lending_contracts lc
  LEFT JOIN public.installment_payments_view ip ON lc.id = ip.contract_id
GROUP BY
  lc.id;

CREATE VIEW public.lending_contracts_view AS
SELECT
  lc.*,
  lcd.debt,
  lcd.extra_debt,
  lcd.last_payment_date,
  coalesce(active_updates.installment, 0) AS installment,
  coalesce(active_updates.interest, 0) AS interest,
  CASE WHEN last_updates.update_date IS NULL THEN
    NULL::json
  ELSE
    json_build_object('update_date', last_updates.update_date, 'installment', coalesce(last_updates.installment, 0), 'interest', coalesce(last_updates.interest, 0))
  END AS next_update
FROM
  public.lending_contracts lc
  LEFT JOIN public.lending_contracts_debts_view lcd ON lc.id = lcd.id
  LEFT JOIN ( SELECT DISTINCT ON (iu.contract_id)
      iu.contract_id,
      iu.installment,
      iu.interest,
      iu.update_date
    FROM
      public.installment_updates iu
    ORDER BY
      iu.contract_id,
      iu.inserted_at DESC) AS last_updates ON lc.id = last_updates.contract_id
  LEFT JOIN ( SELECT DISTINCT ON (iu.contract_id)
      iu.contract_id,
      iu.installment,
      iu.interest,
      iu.update_date
    FROM
      public.installment_updates iu
    WHERE
      iu.update_date <= timezone('utc'::text, now())
    ORDER BY
      iu.contract_id,
      iu.update_date DESC) AS active_updates ON lc.id = active_updates.contract_id;

CREATE VIEW public.renting_contracts_view AS
SELECT
  rc.*,
  coalesce(active_updates.rent, 0) AS rent,
  CASE WHEN next_updates.update_date IS NULL THEN
    NULL::json
  ELSE
    json_build_object('update_date', next_updates.update_date, 'rent', next_updates.rent)
  END AS next_update
FROM
  public.renting_contracts rc
  LEFT JOIN ( SELECT DISTINCT ON (ru.contract_id)
      ru.contract_id,
      ru.rent,
      ru.update_date
    FROM
      public.rent_updates ru
    WHERE
      ru.update_date <= timezone('utc'::text, now())
    ORDER BY
      ru.contract_id,
      ru.update_date DESC) AS active_updates ON rc.id = active_updates.contract_id
  LEFT JOIN ( SELECT DISTINCT ON (ru.contract_id)
      ru.contract_id,
      ru.rent,
      ru.update_date
    FROM
      public.rent_updates ru
    WHERE
      ru.update_date > timezone('utc'::text, now())
    ORDER BY
      ru.contract_id,
      ru.inserted_at DESC) AS next_updates ON rc.id = next_updates.contract_id;

CREATE VIEW public.contracts_view AS
SELECT
  c.*,
  cb.balance,
  CASE WHEN c.type = 'lending'::contract_type THEN
  (
    SELECT
      to_json(lcv.*)
    FROM
      public.lending_contracts_view lcv
    WHERE
      lcv.id = c.id)
  WHEN c.type = 'renting'::contract_type THEN
  (
    SELECT
      to_json(rcv.*)
    FROM
      public.renting_contracts_view rcv
    WHERE
      rcv.id = c.id)
  ELSE
    NULL::json
  END AS data
FROM
  public.contracts c
  LEFT JOIN public.contracts_balances_view cb ON c.id = cb.contract_id;

-- Functions
CREATE FUNCTION public.insert_contract()
  RETURNS TRIGGER
  AS $$
DECLARE
  contract_id bigint;
  inserted_contract contracts_view % ROWTYPE;
BEGIN
  INSERT INTO contracts(type, start_date, end_date, fraction_id)
    VALUES (NEW.type, NEW.start_date, NEW.end_date, NEW.fraction_id)
  RETURNING
    id INTO contract_id;
  IF NEW.type = 'renting' THEN
    INSERT INTO renting_contracts(id)
      VALUES (contract_id);
    INSERT INTO rent_updates(contract_id, update_date, rent)
      VALUES (contract_id, NEW.start_date,(NEW.data ->> 'rent')::double precision);
  ELSIF NEW.type = 'lending' THEN
    INSERT INTO lending_contracts(id, sale_value, down_payment, yearly_raise)
      VALUES (contract_id,(NEW.data ->> 'sale_value')::double precision,(NEW.data ->> 'down_payment')::double precision,(NEW.data ->> 'yearly_raise')::double precision);
    INSERT INTO installment_updates(contract_id, update_date, installment, interest)
      VALUES (contract_id, NEW.start_date,(NEW.data ->> 'installment')::double precision,(NEW.data ->> 'interest')::double precision);
  END IF;
  SELECT
    * INTO inserted_contract
  FROM
    contracts_view
  WHERE
    id = contract_id;
  RETURN inserted_contract;
END;
$$
LANGUAGE plpgsql;

CREATE FUNCTION public.update_contract()
  RETURNS TRIGGER
  AS $$
DECLARE
  contract_id bigint;
  updated_contract contracts_view % rowtype;
BEGIN
  contract_id := NEW.id;
  UPDATE
    contracts
  SET
    start_date = NEW.start_date,
    end_date = NEW.end_date,
    fraction_id = NEW.fraction_id
  WHERE
    id = contract_id;
  IF NEW.type = 'renting' THEN
    INSERT INTO rent_updates(contract_id, update_date, rent)
      VALUES (contract_id, NEW.start_date,(NEW.data ->> 'rent')::double precision);
  ELSIF NEW.type = 'lending' THEN
    UPDATE
      lending_contracts
    SET
      sale_value =(NEW.data ->> 'sale_value')::double precision,
      down_payment =(NEW.data ->> 'down_payment')::double precision,
      yearly_raise =(NEW.data ->> 'yearly_raise')::double precision
    WHERE
      id = contract_id;
    INSERT INTO installment_updates(contract_id, update_date, installment, interest)
      VALUES (contract_id, NEW.start_date,(NEW.data ->> 'installment')::double precision,(NEW.data ->> 'interest')::double precision);
  END IF;
  SELECT
    * INTO updated_contract
  FROM
    contracts_view
  WHERE
    id = contract_id;
  RETURN updated_contract;
END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.update_contract_tenants(p_contract_id bigint, p_tenants bigint[])
  RETURNS void
  AS $$
BEGIN
  DELETE FROM contracts_tenants
  WHERE contract_id = p_contract_id;
  INSERT INTO contracts_tenants(contract_id, tenant_id)
  SELECT
    p_contract_id,
    unnest(p_tenants);
END;
$$
LANGUAGE plpgsql;

CREATE FUNCTION public.insert_rent_payment()
  RETURNS TRIGGER
  AS $$
DECLARE
  movement_id bigint;
BEGIN
  INSERT INTO movements(type, value, date, description)
    VALUES ('rent'::movement_type, NEW.value, NEW.date, NEW.description)
  RETURNING
    id INTO movement_id;
  INSERT INTO rent_payments(contract_id, movement_id)
    VALUES (NEW.contract_id, movement_id);
  RETURN new;
END;
$$
LANGUAGE plpgsql;

CREATE FUNCTION public.remove_rent_payment()
  RETURNS TRIGGER
  AS $$
BEGIN
  DELETE FROM rent_payments
  WHERE id = OLD.id;
  DELETE FROM movements
  WHERE id = OLD.movement_id;
  RETURN old;
END;
$$
LANGUAGE plpgsql;

CREATE FUNCTION public.insert_installment_payment()
  RETURNS TRIGGER
  AS $$
DECLARE
  interest_movement_id bigint;
  DECLARE amortization_movement_id bigint;
BEGIN
  INSERT INTO movements(type, value, date, description)
    VALUES ('installment_interest'::movement_type, NEW.interest, NEW.date, NEW.description)
  RETURNING
    id INTO interest_movement_id;
  IF NEW.amortization > 0 THEN
    INSERT INTO movements(type, value, date, description)
      VALUES ('installment_amortization'::movement_type, NEW.amortization, NEW.date, NEW.description)
    RETURNING
      id INTO amortization_movement_id;
  END IF;
  INSERT INTO installment_payments(contract_id, interest_movement_id, amortization_movement_id, extra_debt)
    VALUES (NEW.contract_id, interest_movement_id, amortization_movement_id, NEW.extra_debt);
  RETURN new;
END;
$$
LANGUAGE plpgsql;

CREATE FUNCTION public.remove_installment_payment()
  RETURNS TRIGGER
  AS $$
BEGIN
  DELETE FROM installment_payments
  WHERE id = OLD.id;
  DELETE FROM movements
  WHERE id = OLD.interest_movement_id;
  DELETE FROM movements
  WHERE id = OLD.amortization_movement_id;
  RETURN old;
END;
$$
LANGUAGE plpgsql;

-- Triggers
CREATE TRIGGER insert_contract
  INSTEAD OF insert ON contracts_view
  FOR EACH ROW
  EXECUTE PROCEDURE public.insert_contract();

CREATE TRIGGER update_contract
  INSTEAD OF UPDATE ON contracts_view
  FOR EACH ROW
  EXECUTE PROCEDURE public.update_contract();

CREATE TRIGGER insert_rent_payment
  INSTEAD OF insert ON rent_payments_view
  FOR EACH ROW
  EXECUTE PROCEDURE public.insert_rent_payment();

CREATE TRIGGER remove_rent_payment
  INSTEAD OF DELETE ON rent_payments_view
  FOR EACH ROW
  EXECUTE PROCEDURE public.remove_rent_payment();

CREATE TRIGGER insert_installment_payment
  INSTEAD OF insert ON installment_payments_view
  FOR EACH ROW
  EXECUTE PROCEDURE public.insert_installment_payment();

CREATE TRIGGER remove_installment_payment
  INSTEAD OF DELETE ON installment_payments_view
  FOR EACH ROW
  EXECUTE PROCEDURE public.remove_installment_payment();

-- Cron Jobs
SELECT
  cron.schedule('create-due-notes', '0 5 1 * *', $$ INSERT INTO public.due_notes(date, value, contract)
    SELECT
      NOW(), CASE WHEN c.type = 'renting'::contract_type THEN
      rc.rent
    WHEN c.type = 'lending'::contract_type THEN
      lc.installment
    ELSE
      0
    END, id FROM public.contracts_view AS c
    WHERE
      c.is_active $$);

